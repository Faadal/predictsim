\documentclass{llncs}

% \usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{mathtools}
\usepackage{wrapfig}
\usepackage{graphicx}
%\usepackage{titling}
\usepackage{float}
\usepackage{caption}
% \usepackage{subcaption}
\usepackage{listings}
%\usepackage{fullpage}
\usepackage[scientific-notation=true]{siunitx}

%Commands for including external source code files
\newcommand{\Sscript}[2]{
  \begin{itemize}
    \item[]\lstinputlisting[caption=#2,label=#1,language=Scilab,basicstyle=\ttfamily\footnotesize,breaklines=true]{#1}
  \end{itemize}
}
\newcommand{\Rscript}[2]{
  \begin{itemize}
    \item[]\lstinputlisting[caption=#2,label=#1,language=R,basicstyle=\ttfamily\footnotesize,breaklines=true]{#1}
  \end{itemize}
}
\newcommand{\Jscript}[2]{
  \begin{itemize}
    \item[]\lstinputlisting[caption=#2,label=#1,language=Java,basicstyle=\ttfamily\footnotesize,breaklines=true]{#1}
  \end{itemize}
}

\newcommand{\Cscript}[2]{
  \begin{itemize}
    \item[]\lstinputlisting[caption=#2,label=#1,language=C,basicstyle=\ttfamily\footnotesize,breaklines=true]{#1}
  \end{itemize}
}

\newcommand{\Pscript}[2]{
  \begin{itemize}
    \item[]\lstinputlisting[caption=#2,label=#1,language=Python,basicstyle=\ttfamily\footnotesize,breaklines=true]{#1}
  \end{itemize}
}

\lstdefinelanguage{codeoutput} { %this is the name that you are going to use when you want to use the formatting
  basicstyle=\ttfamily\scriptsize, %font family & size
}
\newcommand{\Oscript}[2]{
  \begin{itemize}
    \item[]\lstinputlisting[caption=#2,label=#1,language=codeoutput]{src/#1}
  \end{itemize}
}

\setlength{\abovecaptionskip}{1pt plus 1pt minus 1pt} % Chosen fairly arbitrarily






\begin{document}
\mainmatter


\author{Ivar Ekeland\inst{1} \and Roger Temam\inst{2}
Jeffrey Dean \and David Grove \and Craig Chambers \and Kim~B.~Bruce \and
Elsa Bertino}

\institute{Princeton University, Princeton NJ 08544, USA,\\
\email{I.Ekeland@princeton.edu},\\ WWW home page:
\texttt{http://users/\homedir iekeland/web/welcome.html}
\and
Universit\'{e} de Paris-Sud,
Laboratoire d'Analyse Num\'{e}rique, B\^{a}timent 425,\\
F-91405 Orsay Cedex, France}

\maketitle              % typeset the title of the contribution

\begin{abstract}

Abstract is here.
\keywords{computational geometry, graph theory, Hamilton cycles}

\end{abstract}






\section{Introduction}
\label{sec:introduction}
constat: l'estimation -user des runtimes est mauvaise. (est plutôt une deadline)

Les batch schedulers sont des politiques rudimentaires, simples et robustes (FIFO backfilling), qui guarantissent l'absence de famine. Ces politiques permettent une forte utilisation de la machine.
Les politiques prop. (eg torque pbs ) sont légèrement plus sophistiquées mais restent basées sur des listes.\

question: peut-on tirer parti d'une meilleure conaissance des temps de prédiction afin de mieux gérer les ressources?

On montre ici qu'en se basant sur des techniques classiques de prédiction, il es possible d'améliorer  l'allocation obtenue avec les politiques classiques (ici backfilling.).
Détail de la contribution:
-comment prédire
-nouvelles politiques pour utiliser ces prédictions
-validation expérimentale

\section{Problem Statement}
\label{sec:problem_statement}

\section{Learning}
\label{sec:learning}
Runtime prediction has first been attempted~\cite{gibbons} by classifying jobs according to predefined set of rules. In this method, the partitioning had to be provided by the RMS or the system administrator. This method is an ancestor of tree-based regression models which assume the job characteristics to be identically distributed and independent. It does not make use of dependency between successive jobs. Moreover, the binning had to be obtained trough careful, manual statistical analysis of the specific system and population.

A model~\cite{hmm} has been proposed for predicting full job run-time distributions. This technique only relies on historical run-time information as opposed to previous works that only used job descriptions. It treats successive run-times of a given user as the observations of a Hidden Markov Model~\cite{rabiner}, hence it does not make the hypothesis that jobs submission are the result of an independent sampling of a distribution.
A related, but much simpler approach~\cite{tsafir} averages the two last available run-times of the job's user. It enjoys surprising success given its simplicity.

Our approach is that of combining both job descriptions and temporal dependency of run-times. We chose to combine both informations with an on-line linear regression approach:


\section{Scheduling strategies}
\label{sec:scheduling_strategies}

\subsection{Objective Functions}
\label{sub:objective_functions}

\subsection{Backfilling with Correction}
\label{sub:backfilling_with_correction}


\section{Experimental Validation}
\label{sec:experimental_validation}

\section{Conclusion}
\label{sec:conclusion}

\section*{Acknowledgements.}
\label{sec:ack}
merci yannis ect

-cite
workload archive
pyss


\bibliographystyle{splncs03}
\bibliography{references}


\end{document}
