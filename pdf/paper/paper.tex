\documentclass{llncs}

% \usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{mathtools}
\usepackage{wrapfig}
\usepackage{graphicx}
%\usepackage{titling}
\usepackage{float}
\usepackage{caption}
% \usepackage{subcaption}
\usepackage{listings}
%\usepackage{fullpage}
\usepackage[scientific-notation=true]{siunitx}

%Commands for including external source code files
\newcommand{\Sscript}[2]{
  \begin{itemize}
    \item[]\lstinputlisting[caption=#2,label=#1,language=Scilab,basicstyle=\ttfamily\footnotesize,breaklines=true]{#1}
  \end{itemize}
}
\newcommand{\Rscript}[2]{
  \begin{itemize}
    \item[]\lstinputlisting[caption=#2,label=#1,language=R,basicstyle=\ttfamily\footnotesize,breaklines=true]{#1}
  \end{itemize}
}
\newcommand{\Jscript}[2]{
  \begin{itemize}
    \item[]\lstinputlisting[caption=#2,label=#1,language=Java,basicstyle=\ttfamily\footnotesize,breaklines=true]{#1}
  \end{itemize}
}

\newcommand{\Cscript}[2]{
  \begin{itemize}
    \item[]\lstinputlisting[caption=#2,label=#1,language=C,basicstyle=\ttfamily\footnotesize,breaklines=true]{#1}
  \end{itemize}
}

\newcommand{\Pscript}[2]{
  \begin{itemize}
    \item[]\lstinputlisting[caption=#2,label=#1,language=Python,basicstyle=\ttfamily\footnotesize,breaklines=true]{#1}
  \end{itemize}
}

\lstdefinelanguage{codeoutput} { %this is the name that you are going to use when you want to use the formatting
  basicstyle=\ttfamily\scriptsize, %font family & size
}
\newcommand{\Oscript}[2]{
  \begin{itemize}
    \item[]\lstinputlisting[caption=#2,label=#1,language=codeoutput]{src/#1}
  \end{itemize}
}

\setlength{\abovecaptionskip}{1pt plus 1pt minus 1pt} % Chosen fairly arbitrarily






\begin{document}
\mainmatter


\title{Does runtime prediction matter?}

\author{Eric Gaussier\inst{1} \and David Glesser\inst{2}
Denis Trystram\inst{3} \and Valentin Reis\inst{4}}

\institute{Universisty of TODO\\
\email{TODO@TODO.com},
\and
Universisty of TODO\\
\email{TODO@TODO.com},
\and
Universisty of TODO\\
\email{TODO@TODO.com},
\and
Universisty of TODO\\
\email{TODO@TODO.com}}

\maketitle              % typeset the title of the contribution

\begin{abstract}

Abstract is here.
\keywords{computational geometry, graph theory, Hamilton cycles}

\end{abstract}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
\label{sec:introduction}
constat: l'estimation -user des runtimes est mauvaise. (est plutôt une deadline)

Les batch schedulers sont des politiques rudimentaires, simples et robustes (FIFO backfilling), qui guarantissent l'absence de famine. Ces politiques permettent une forte utilisation de la machine.
Les politiques prop. (eg torque pbs ) sont légèrement plus sophistiquées mais restent basées sur des listes.\

question: peut-on tirer parti d'une meilleure conaissance des temps de prédiction afin de mieux gérer les ressources?

On montre ici qu'en se basant sur des techniques classiques de prédiction, il es possible d'améliorer  l'allocation obtenue avec les politiques classiques (ici backfilling.).
Détail de la contribution:
-comment prédire
-nouvelles politiques pour utiliser ces prédictions
-validation expérimentale





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Problem Statement}
\label{sec:problem_statement}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Learning}
\label{sec:learning}
Runtime prediction has first been attempted~\cite{gibbons} by clustering jobs according to a predefined set of rules and using the cluster mean as a prediction. In this method, often-times called "Templates" by subsequent authors, the partitioning has to be provided by the RMS or the system administrator. This method is an ancestor of tree-based regression models. Moreover, the binning has to be obtained trough careful, manual statistical analysis of the specific system and population. The technique was subsequently adapted~\cite{gibbons-GA} using a more automatic way to generate the rules.

Other approaches leverage CPU load information from the machine~\cite{predict-load}, or use more application-centric modeling ~\cite{Schopf99usingstochastic}\cite{Nadeem:2009:PET:1654059.1654093}\cite{6495803}.

A recent survey~\cite{ML-predictruntime-survey} compares methods based on generic supervised learning tools.

All these approaches assume jobs and their run-times to be identically distributed and independent. Therefore it does not make use of dependency between successive jobs.

A stochastic model~\cite{hmm} has been proposed for predicting full job run-time distributions. This technique only relies on historical run-time information as opposed to previous works that only used job descriptions. It treats successive run-times of a given user as the observations of a Hidden Markov Model~\cite{rabiner}, hence it does not make the hypothesis that jobs submission are the result of an independent sampling of a distribution.
A related, but much simpler approach~\cite{tsafir} averages the two last available run-times of the job's user as a prediction. It enjoys surprising success given its simplicity.

Our approach is that of combining both job descriptions and temporal dependency of run-times through online linear regression.

We describe here our model.

TODO:

A job is maped to a vector $x \in \mathbb{R}^{n}$ where $n$ is the number of features of our model.
The prediction is achieved via a Generalized Linear Model..




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Scheduling strategies}
\label{sec:scheduling_strategies}

\subsection{Objective Functions}
\label{sub:objective_functions}

\subsection{Backfilling with Correction}
\label{sub:backfilling_with_correction}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Experimental Validation}
\label{sec:experimental_validation}

\subsection{Testbed}
\label{sub:Testbed}
Use Pyss, core improved to a newer python version and add algo. Code sourve available there XX.
Tests the following algo:
- 
- 

Tests with the following workload (from the FWA):
- CEA-curie
- CTC-SP2
- KTH-SP2
- SDSC-BLUE
- SDSC-SP2
- More? (see used traces for FSE)


\subsection{Results}
\label{sub:Testbed}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}
\label{sec:conclusion}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Acknowledgements.}
\label{sec:ack}
merci yannis ect

-cite
workload archive
pyss


\bibliographystyle{splncs03}
\bibliography{bibliography}


\end{document}
